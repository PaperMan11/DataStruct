[TOC]

# 1 BitMap
## 1.1 BitMap 介绍
&emsp;&emsp;BitMap 的基本思想就是用一个 bit 位来标记某个元素对应的 value ，由于采用了 Bit 位来存储数据，因此可以**节省**大量的存储空间。假设我们要在 32 位操作系统存储 20 亿个随机整数。
- 每个数字通过 int 存储（4byte 8bit），占用空间约为（2000000000*4*1024*1024*1024）≈ 7.45G
- 按位存储，20 亿就是 20 亿位。占用空间约为（2000000000/8/1024/1024/1024）≈ 0.233G

### 1.1.1 判断数字在 bit 数组中的位置
在代码中我们通过 `[]byte` 来存储 bit 数据，由于 1byte = 8bit。因此：
- bits[0] 表示 0~7，bits[1] 表示 8~15，一次类推
- num / 8 = num在当前 `[]byte` 中的位置
- num % 8 = num在当前字节的位置

**例如：数字 10**
- 10 / 8 = 1，即数字 10 对应的 `[]byte` 的位置为：1
- 10 % 8 = 2，即数字 10 在当前字节中的位置为：2 

### 1.1.2 将数字设置到 bit 数组
- num / 8 得到数字在字节数组中的位置 => row
- num % 8 得到数字在当前字节中的位置 => col
- 公式：`bits[row] | 1 << (col)`

### 1.1.3 将 bit 数组中的数字清除
- num / 8 得到数字在字节数组中的位置 => row
- num % 8 得到数字在当前字节中的位置 => col
- 公式：`bits[row] & ~(1 << (col))`

### 1.1.4 查找 数字是否在 bit 数组中
- num / 8 得到数字在字节数组中的位置 => row
- num % 8 得到数字在当前字节中的位置 => col
- 公式：`bits[row] & 1 << (col)`

### 1.1.5 BitMap 的应用
- 数据去重，数据快速查找
- 快速排序：将数字加入 bit-map ，然后遍历出来就达到了快速排序的效果。
    - 优点：运算效率高，不需要进行比较和移位；占用内存少
    - 缺点：所有数据不能重复；只有数据较密集时才有优势

## 1.2 Go 语言位运算
- & 按位与：两者全为1结果为1，否则结果为0
- | 按位或：两者有一个为1结果为1，否则结果为0
- ^ 按位异或：两者不同结果为1，否则结果为0
- &^ 按位与非：是"与"和"非"操作符的简写形式
- << 按位左移：
- \>> 按位右移：


# 2 布隆过滤器
## 2.1 介绍
&emsp;&emsp;布隆过滤器是由一个固定大小的二进制向量或者位图（bit-map）和一系列 hash 函数组成的。在初始状态时，对于长度为 m 的位数组，它的所有位都被置为 0 。当有变量加入集合时，通过 K 个 hash 函数将这个变量映射到 bit-map 上的 K 个点（即置为1）。查询变量，通过 K 个 hash 函数再次计算：
- 如果是0，则被查询的变量一定不存在
- 如果都是1，则被查询的变量可能存在（hash 函数存在碰撞情况）

**布隆过滤器特点：**
- 一个元素如果判断结果为存在的时候元素不一定存在（存在误判率），但是判断结果为不存在的时候则一定不存在。
- 布隆过滤器可以添加元素，但是不能删除元素。因为删掉元素会导致误判率增加。
- 优点：相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。
- 缺点：布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。

## 2.2 使用场景
- WEB拦截器，如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务。
- 避免缓存击穿：在缓存前加一层屏障，里面存储目前数据库中存在的所有key，若在布隆过滤器中没有查询到，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回null。
