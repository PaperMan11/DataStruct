## 1 并查集
并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。

并查集的思想是用一个数组表示了整片森林（parent），树的根节点唯一标识了一个集合，我们只要找到了某个元素的的树根，就能确定它在哪个集合里。

## 2 基本数据展示
```go

      id    | 0 1 2 3 4 5 6
    集合编号 | 0 1 0 2 1 2 1
```

其中 `0 2 5` 为一个集合，表示这三个数是相连的，`1 4 6` 为另一个集合表示这三个数是相连的。

## 3 UnionFind
```go
type UnionFind struct {
	rank   []int // rank[i]表示以i为根的集合所表示的树的层数
	parent []int // parent[i]表示第i个元素所指向的父节点
	count  int   // 数据个数
}
```

### 3.1 路径压缩算法之一（优化find( )函数）
```go
5-4-3-2
        \
         1
        /
9-8-7-6
```

我们通过合并其他集合可能会出现以上的树形结构，可以发现我们如果不指定指向前驱的规则，就可能出现单叉树结构（一字蛇形），这样就会在造成查找时的效率低下。我们最理想的情况是所有的节点都指向 1，所以就可做如下优化：
```go
func (u *UnionFind) Find(p int) int {
	...
	if p != u.parent[p] {
		// compress: 减小树的高度 rank 优化（变宽）
		u.parent[p] = u.Find(u.parent[p])
	}
	...
}
```

但是该算法存在一个缺陷，只有当查找了某个节点的代表元后，才能对该查找路径上的各节点进行路径压缩。换言之，第一次执行查找操作的时候是实现没有压缩效果的，只有在之后才有效。

### 3.2 路径压缩算法之二（加权标记法）
加权标记法需要将树中所有节点都增设一个权值，用以表示该节点所在树中的高度（比如用 `rank[x]=3` 表示 x 节点所在树的高度为 3）。这样一来，在合并操作的时候就能通过这个权值的大小来决定谁当谁的上级。

在合并操作的时候，假设需要合并的两个集合的代表元分别为 x 和 y，则只需要令 `prarent[x] = y` 或者 `prarent[y] = x` 即可。但我们为了使合并后的树不产生退化（即：使树中左右子树的深度差尽可能小），那么对于每一个元素 x ，增设一个 `rank[x]` 数组，用以表达子树 x 的高度。在合并时，如果 `rank[x] < rank[y]`，则令 `prarent[x] = y`；否则令 `prarent[y] = x`。

```go
func (u *UnionFind) UnionElements(p, q int) {
	...
	if u.rank[x] < u.rank[y] {
		u.parent[x] = y
	} else if u.rank[x] > u.rank[y] {
		u.parent[y] = x
	} else {
		u.parent[x] = y
		u.rank[y]++
	}
}
```
